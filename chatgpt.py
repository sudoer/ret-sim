from re import M
import numpy as np
import random
from scipy.stats import t


# These functions were generated by OpenAI's GPT-3 model.
# They are not meant to be comprehensive, but just "good enough" for estimates.

def estimate_income_tax(income, married=False):
    """
    Estimate U.S. federal income tax owed based on taxable income for single filers (2023 brackets).

    Parameters:
        income (float): Taxable income in dollars.

    Returns:
        float: Estimated federal income tax.
    """
    # 2024 Federal income tax brackets for single filers
    single_brackets = [
        (0, 11_600, 0.10),
        (11_601, 47_150, 0.12),
        (47_151, 100_525, 0.22),
        (100_526, 191_950, 0.24),
        (191_951, 243_725, 0.32),
        (243_726, 609_350, 0.35),
        (609_351, float("inf"), 0.37),
    ]
    # 2024 Federal income tax brackets for married filers
    married_joint_brackets = [
        (0, 22_000, 0.10),  # 10% on income up to $22,000
        (22_001, 89_450, 0.12),  # 12% on income from $22,001 to $89,450
        (89_451, 190_750, 0.22),  # 22% on income from $89,451 to $190,750
        (190_751, 364_200, 0.24),  # 24% on income from $190,751 to $364,200
        (364_201, 462_500, 0.32),  # 32% on income from $364,201 to $462,500
        (462_501, 693_750, 0.35),  # 35% on income from $462,501 to $693,750
        (693_751, float("inf"), 0.37),  # 37% on income over $693,750
    ]

    tax_owed = 0.0

    brackets = single_brackets if not married else married_joint_brackets

    for lower, upper, rate in brackets:
        if income > lower:
            taxable_amount = min(income, upper) - lower
            tax_owed += taxable_amount * rate
        else:
            break

    return round(tax_owed, 2)


def calculate_rmd(account_balance, age):
    """
    Calculate the Required Minimum Distribution (RMD) for an IRA.

    Parameters:
        account_balance (float): The total balance in the IRA at the end of the previous year.
        age (int): The account holder's age as of December 31 of the current year.

    Returns:
        float: The estimated RMD for the given age and account balance.
    """
    # Uniform Lifetime Table divisor values
    uniform_lifetime_table = {
        72: 25.6,
        73: 24.7,
        74: 23.8,
        75: 22.9,
        76: 22.0,
        77: 21.2,
        78: 20.3,
        79: 19.5,
        80: 18.7,
        81: 17.9,
        82: 17.1,
        83: 16.3,
        84: 15.5,
        85: 14.8,
        86: 14.1,
        87: 13.4,
        88: 12.7,
        89: 12.0,
        90: 11.4,
        91: 10.8,
        92: 10.2,
        93: 9.6,
        94: 9.1,
        95: 8.6,
        96: 8.1,
        97: 7.6,
        98: 7.1,
        99: 6.7,
        100: 6.3,
        101: 5.9,
        102: 5.5,
        103: 5.2,
        104: 4.9,
        105: 4.5,
        106: 4.2,
        107: 3.9,
        108: 3.7,
        109: 3.4,
        110: 3.1,
        111: 2.9,
        112: 2.6,
        113: 2.4,
        114: 2.1,
        115: 1.9,
    }

    # Check if age is in the table
    if age not in uniform_lifetime_table:
        raise ValueError("Age must be between 72 and 115 to calculate RMD.")

    # Get the divisor for the given age
    divisor = uniform_lifetime_table[age]

    # Calculate RMD
    rmd = account_balance / divisor
    return rmd


def gaussian_guess(mean, std_dev, min_value=None, max_value=None):
    while True:
        # Generate a value from a normal distribution
        inflation = random.gauss(mean, std_dev)
        # Constrain the value to the specified range
        if min_value is not None and inflation < min_value:
            continue
        if max_value is not None and inflation > max_value:
            continue
        return round(inflation, 2)


def random_inflation(mean=3.0, std_dev=2.0, min_value=-2.0, max_value=15.0):
    """
    Generate a random-like inflation value in line with historical trends.

    Parameters:
        mean (float): The average inflation rate (default is 3.0%).
        std_dev (float): The standard deviation for variability (default is 2.0%).
        min_value (float): The minimum inflation rate allowed (default is -2.0%).
        max_value (float): The maximum inflation rate allowed (default is 15.0%).

    Returns:
        float: A random inflation rate, constrained to the given range.
    """
    return gaussian_guess(mean, std_dev, min_value, max_value)


def get_full_retirement_age(birth_year: int) -> float:
    """
    Calculate the Full Retirement Age (FRA) for Social Security based on birth year.
    :param birth_year: Year of birth (integer)
    :return: FRA as a floating-point number (years.months/12)
    """
    if birth_year <= 1937:
        return 65.0
    elif 1938 <= birth_year <= 1942:
        months = (birth_year - 1937) * 2
        return 65 + months / 12
    elif 1943 <= birth_year <= 1954:
        return 66.0
    elif 1955 <= birth_year <= 1959:
        months = (birth_year - 1954) * 2
        return 66 + months / 12
    elif birth_year >= 1960:
        return 67.0
    else:
        raise ValueError("Invalid birth year")


def random_fund_return(
        average_annual_return_pct,
        annual_volatility_pct,
        seed=None
) -> float:
    """
    Simulates one year of returns and returns the resulting annual return percentage.

    Parameters:
        average_annual_return_pct (float): Expected average annual return (e.g. 10 for 10%)
        annual_volatility_pct (float): Annualized volatility (e.g. 20 for 20%)
        seed (int or None): Random seed for reproducibility

    Returns:
        float: Simulated annual return as a percentage (e.g., 12.34 means 12.34%)
    """
    average_annual_return_float = average_annual_return_pct / 100.0
    annual_volatility_float = annual_volatility_pct / 100.0

    if seed is not None:
        np.random.seed(seed)

    days = 252  # Trading days in a year
    daily_return = average_annual_return_float / days
    daily_volatility = annual_volatility_float / np.sqrt(days)

    # Generate random daily returns
    daily_returns = np.random.normal(daily_return, daily_volatility, days)

    # Simulate price path
    cumulative_return = np.prod(1 + daily_returns) - 1

    # Return as percentage
    return round(cumulative_return * 100, 2)


def simulate_year_return_tdist_percent(
    annual_return_pct=7,       # e.g., 7 means +7%
    annual_volatility_pct=15,  # e.g., 15 means 15%
    t_df=6
):
    """
    Simulate ONE year's return as an integer percent using a t-distribution.
    Example output: 12 for +12%, -18 for -18%.
    """
    # Convert integer percents to decimals
    mu = annual_return_pct / 100
    sigma = annual_volatility_pct / 100

    # t-distributed shock
    z = t.rvs(df=t_df)

    # normalize t so variance = 1
    z = z / np.sqrt(t_df / (t_df - 2))

    # simulated decimal return
    r = mu + sigma * z

    # convert back to whole-number percent
    return int(round(r * 100))
